code for prob1 (in java)

import java.util.PriorityQueue;
import java.util.ArrayList;
public class test{


    public static class Pair{
        int chunkNo;
        Character[] data;
        public Pair(int chunk,Character[] data){
            this.chunkNo = chunk;
            this.data = data;
        }
    }
    //gobal queue which stores all chunk and data in the form of Pair ,and will return them on basis of the chunk no(smaller chunk will be returned first)
    static PriorityQueue<Pair> queue;
    //used to record whether chunk=1 is entered or not
    static int startingChunk;
    public static void main(String[] args) {
        
        queue = new PriorityQueue<>((a,b)->Integer.compare(a.chunkNo, b.chunkNo));
        startingChunk = 0;

        //Here the receive and read functions can be called to register or return chunk and its data.

    }

    

    public static void receive(int chunk,Character[] data){
        Pair np = new Pair(chunk,data);
        queue.add(np);

    }
    public static ArrayList<Character>  read(){
        ArrayList<Character> answer = new ArrayList<>();
        if(queue.size()==0){
            return answer;
        }
        if(startingChunk==0){
            if(queue.peek().chunkNo!=1){
                return answer;
            }
            startingChunk=1;
            //this signifies that the first chunk(1) has been used and now new entry of any other chunk will be considered the first chunk.If its value is 0 and first chunk is not present,empty list will be returned
        }
        
        while(queue.size()!=0){
            Pair rp = queue.remove();
            Character[] arr = rp.data;
            for(Character e: arr){
                answer.add(e);
            }
        }


        return answer;
    }
}










code for prob2(in java)


import java.util.zip.*; 
import java.io.UnsupportedEncodingException; 
//RLE is Lossless compression algorithm that can be utilized for string compression in java. RLE follows the same concept of identifying the patterns and allocating a code . It can also be used for string compression in java but java does not offer a particular class or function for implementing RLE. It can be easily performed using the StringBuilder class

public class test2 {
    public static void main(String[] args) {
        
        // we have written 2 separate functions ,for compression and decompression
        string = "abcdefgh";
        String compressed = compression(string);
    }
    static String string;

    public static String compression(String comStr) {
        		// To check if the string to be compressed in empty.
        	        if (str == null || comStr.isEmpty()) return "";
        	        StringBuilder strBuilder = new StringBuilder();
        	        char[] chars = comStr.toCharArray();
        	        char current = chars[0];
    	        int counter = 1;
        	 
    	        for (int i = 1; i < chars.length; i++) {
        	            if (current == chars[i]){
    	                counter++;
        	            } else {
        	                if (counter > 1) strBuilder.append(counter);
        	                strBuilder.append(current);
    	                current = chars[i];
        	                counter = 1;
        	            }
        	        }
        	        if (counter > 1) strBuilder.append(counter);
        	        strBuilder.append(current);
        	        return strBuilder.toString();
            }

    public static String decompression(String decomStr) {
        	        if (string == null || decomStr.isEmpty()) return "";
        	 
        	        StringBuilder strbuilder = new StringBuilder();
        	        char[] chars = decomStr.toCharArray();
        	        boolean preIsDigit = false;
        	        String digitsString = "";
        	        for(char current: chars) {
        	            if (!Character.isDigit(current)) {
        	                if (preIsDigit){
        	                    String multipleString = new String(new char[Integer.valueOf(digitsString)]).replace("\0",current+"");
        	                    strBuilder.append(multipleString);
        	                    preIsDigit = false;
        	                    digitString = "";
        	                } else{
        	                    strBuilder.append(current);
        	                }
        	            } else {
        	                digitsString+=current;
        	                preIsDigit = true;
        	            }
        	        }
        	        return strBuilder.toString();
        	    }

    

        
    

    
   

  
}